// file: ftl_debug.h
/**************************************************************************
* Copyright (C)2012 Spansion Inc. All Rights Reserved. 
*
* This software is owned and published by: 
* Spansion Inc, 915 DeGuigne Dr. Sunnyvale, CA  94088-3453 ("Spansion").
*
* BY DOWNLOADING, INSTALLING OR USING THIS SOFTWARE, YOU AGREE TO BE BOUND 
* BY ALL THE TERMS AND CONDITIONS OF THIS AGREEMENT.
*
* This software constitutes driver source code for use in programming Spansion's 
* Flash memory components. This software is licensed by Spansion to be adapted only 
* for use in systems utilizing Spansion's Flash memories. Spansion is not be 
* responsible for misuse or illegal use of this software for devices not 
* supported herein.  Spansion is providing this source code "AS IS" and will 
* not be responsible for issues arising from incorrect user implementation 
* of the source code herein.  
*
* SPANSION MAKES NO WARRANTY, EXPRESS OR IMPLIED, ARISING BY LAW OR OTHERWISE, 
* REGARDING THE SOFTWARE, ITS PERFORMANCE OR SUITABILITY FOR YOUR INTENDED 
* USE, INCLUDING, WITHOUT LIMITATION, NO IMPLIED WARRANTY OF MERCHANTABILITY, 
* FITNESS FOR A  PARTICULAR PURPOSE OR USE, OR NONINFRINGEMENT.  SPANSION WILL 
* HAVE NO LIABILITY (WHETHER IN CONTRACT, WARRANTY, TORT, NEGLIGENCE OR 
* OTHERWISE) FOR ANY DAMAGES ARISING FROM USE OR INABILITY TO USE THE SOFTWARE, 
* INCLUDING, WITHOUT LIMITATION, ANY DIRECT, INDIRECT, INCIDENTAL, 
* SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS OF DATA, SAVINGS OR PROFITS, 
* EVEN IF SPANSION HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.  
*
* This software may be replicated in part or whole for the licensed use, 
* with the restriction that this Copyright notice must be included with 
* this software, whether used in part or whole, at all times.  
*/
/* external APIs suppied to the outside world */
/*This file will contain API declerations, to be used for FTL debug in the event of the FTL failure*/

#ifndef FTL_DEBUG_H
#define FTL_DEBUG_H

#include "ftl_def.h"

#if (FTL_ENABLE_DEBUG_CODE == FTL_TRUE)
#define FTL_DEBUG_BASE_ERROR_NUMBER 10000
FTL_STATUS FTL_DebugStructSize(void);
/*EBLOCK MAPPING ENTRY*/
#define EXPECTED_EBLOCK_MAPPING_ENTRY_SIZE (EBLOCK_MAPPING_ENTRY_SIZE)
#define FTL_EBLOCK_MAPPING_ENTRY_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 1);
#define FTL_EBLOCK_MAPPING_ARRAY_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 2);
#define FTL_EBLOCK_MAPPING_ARRAY_MISALIGNED  (FTL_DEBUG_BASE_ERROR_NUMBER + 3);
/*PPA*/
#define EXPECTED_PPA_MAPPING_ENTRY_SIZE (PPA_MAPPING_ENTRY_SIZE)
#define FTL_PPA_ENTRY_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 4);
#define FTL_PPA_ARRAY_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 5);
#define FTL_PPA_ARRAY_MISALIGNED  (FTL_DEBUG_BASE_ERROR_NUMBER + 6);
/*PPA DIRTY BIT MAP*/
#define EXPECTED_PPA_DIRTY_BITMAP_ENTRY_SIZE (1)
#define FTL_PPA_DIRTY_ENTRY_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 7);
#define FTL_PPA_DIRTY_ARRAY_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 8);
#define FTL_PPA_DIRTY_ARRAY_MISALIGNED  (FTL_DEBUG_BASE_ERROR_NUMBER + 9);
/*EBLOCK MAP DIRTY BIT MAP*/
#define EXPECTED_EBLOCK_MAP_DIRTY_BITMAP_ENTRY_SIZE (1)
#define FTL_EBLOCK_MAP_DIRTY_ENTRY_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 10);
#define FTL_EBLOCK_MAP_DIRTY_ARRAY_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 11);
#define FTL_EBLOCK_MAP_DIRTY_ARRAY_MISALIGNED  (FTL_DEBUG_BASE_ERROR_NUMBER + 12);
/*Flush Log EB Array*/

#define EXPECTED_FLUSH_LOG_ENTRY_SIZE (2 + 2 + 4)
#define FTL_FLUSH_LOG_ENTRY_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 13);
#define FTL_FLUSH_LOG_ARRAY_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 14);
#define FTL_FLUSH_LOG_ARRAY_MISALIGNED  (FTL_DEBUG_BASE_ERROR_NUMBER + 15);
/*Trans Log Array*/

#define EXPECTED_TRANS_LOG_ENTRY_SIZE (2 + 2 + 4)
#define FTL_TRANS_LOG_ENTRY_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 16);
#define FTL_TRANS_LOG_ARRAY_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 18);
#define FTL_TRANS_LOG_ARRAY_MISALIGNED  (FTL_DEBUG_BASE_ERROR_NUMBER + 19);
/*Flush Log Array Count*/

#define EXPECTED_FLUSH_LOG_ARRAY_COUNT_SIZE (2)
#define FTL_FLUSH_LOG_ENTRY_COUNT_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 20);
#define FTL_FLUSH_LOG_ARRAY_COUNT_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 21);
#define FTL_FLUSH_LOG_ARRAY_COUNT_MISALIGNED  (FTL_DEBUG_BASE_ERROR_NUMBER + 22);
/*Trans Log Array Count*/

#define EXPECTED_TRANS_LOG_ARRAY_COUNT_SIZE (2)
#define FTL_TRANS_LOG_ENTRY_COUNT_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 23);
#define FTL_TRANS_LOG_ARRAY_COUNT_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 24);
#define FTL_TRANS_LOG_ARRAY_COUNT_MISALIGNED  (FTL_DEBUG_BASE_ERROR_NUMBER + 25);
/*Trans log counters*/

#define EXPECTED_TRANS_LOG_ARRAY_COUNT_SIZE_2 (4)
#define FTL_TRANS_LOG_ENTRY_COUNT_SIZE_MISMATCH_2 (FTL_DEBUG_BASE_ERROR_NUMBER + 26);
#define FTL_TRANS_LOG_ARRAY_COUNT_SIZE_MISMATCH_2 (FTL_DEBUG_BASE_ERROR_NUMBER + 26);
#define FTL_TRANS_LOG_ARRAY_COUNT_MISALIGNED_2  (FTL_DEBUG_BASE_ERROR_NUMBER + 27);
/*Flush Log Counters*/

#define EXPECTED_FLUSH_LOG_ARRAY_COUNT_SIZE_2 (4)
#define FTL_FLUSH_LOG_ENTRY_COUNT_SIZE_MISMATCH_2 (FTL_DEBUG_BASE_ERROR_NUMBER + 28);
#define FTL_FLUSH_LOG_ARRAY_COUNT_SIZE_MISMATCH_2 (FTL_DEBUG_BASE_ERROR_NUMBER + 29);
#define FTL_FLUSH_LOG_ARRAY_COUNT_MISALIGNED_2  (FTL_DEBUG_BASE_ERROR_NUMBER + 30);
/*GC NUm*/
//extern  UINT32  GCNum[NUM_DEVICES];
#define EXPECTED_GC_NUM_STRUCT_SIZE (4)
#define FTL_GC_NUM_ENTRY_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 31);
#define FTL_GC_NUM_ARRAY_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 32);
#define FTL_GC_NUM_ARRAY_MISALIGNED  (FTL_DEBUG_BASE_ERROR_NUMBER + 33);
/*GC_Info*/
//extern  GC_INFO  GC_Info;
#define EXPECTED_GC_INFO_STRUCT_SIZE (1 + 2 + 1 + 2 + 4 + 4 + 1 + 2 + 4 + 4)
#define FTL_GC_INFO_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 34);
#define FTL_GC_INFO_STRUCT_MISALIGNED  (FTL_DEBUG_BASE_ERROR_NUMBER + 34);
/*GC THRESHOLD*/

#define EXPECTED_GC_THRESHOLD_SIZE (2)
#define FTL_GC_THRESHOLD_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 35);
#define FTL_GC_THRESHOLD_MISALIGNED  (FTL_DEBUG_BASE_ERROR_NUMBER + 36);

/*TransferMapIndexEnd*/

#define EXPECTED_TransferMapIndexEnd_SIZE (2)
#define FTL_TransferMapIndexEnd_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 37);
#define FTL_TransferMapIndexEnd_MISALIGNED  (FTL_DEBUG_BASE_ERROR_NUMBER + 38);
/*TransferMapIndexStart*/

#define EXPECTED_TransferMapIndexStart_SIZE (2)
#define FTL_TransferMapIndexStart_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 39);
#define FTL_TransferMapIndexStart_MISALIGNED  (FTL_DEBUG_BASE_ERROR_NUMBER + 40);

/*Transfer Map*/

#define EXPECTED_TRANSFER_MAP_STRUCT_STRUCT_SIZE (1 + 1 + 1 + 4 + 4 + 4 + 2)
#define FTL_TRANSFER_MAP_STRUCT_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 41);
#define FTL_TRANSFER_MAP_STRUCT_ARRAY_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 42);
#define FTL_TRANSFER_MAP_STRUCT_ARRAY_MISALIGNED  (FTL_DEBUG_BASE_ERROR_NUMBER + 43);

/*GC move array*/
//extern  UINT8  GCMoveArray[NUM_PAGES_PER_EBLOCK]; 
#define EXPECTED_GC_MOVE_ARRAY_STRUCT_SIZE (1)
#define FTL_GC_MOVE_ARRAY_STRUCT_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 44);
#define FTL_GC_MOVE_ARRAY_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 45);
#define FTL_GC_MOVE_ARRAY_MISALIGNED  (FTL_DEBUG_BASE_ERROR_NUMBER + 46);

/*Trans log Entry*/

#define EXPECTED_TLOG_STRUCT_SIZE ((2 + 1 + 1 + ((2+2)*2) + 4) + (2 + 1 + 1 + ((2+2)*3)) + (2 + 1 + 1 + ((2+ 2)* 2) + 4))
#define FTL_TLOG_STRUCT_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 47);
#define FTL_TLOG_STRUCT_MISALIGNED  (FTL_DEBUG_BASE_ERROR_NUMBER + 48);
/*TranslogBEntries*/

#define EXPECTED_TLOGB_SIZE (2)
#define FTL_TLOGB_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 49);
#define FTL_TLOGB_MISALIGNED  (FTL_DEBUG_BASE_ERROR_NUMBER + 50);
/* LastTransLogLba*/
//extern     UINT32                 LastTransLogLba;
#define EXPECTED_LAST_LBA_SIZE (4)
#define FTL_LAST_LBA_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 51);
#define FTL_LAST_LBA_MISALIGNED  (FTL_DEBUG_BASE_ERROR_NUMBER + 52);

/*pseudoRPB*/
//extern     UINT8                  pseudoRPB[NUM_DEVICES][VIRTUAL_PAGE_SIZE];
#define EXPECTED_pseudoRPB_STRUCT_SIZE (1)
#define FTL_pseudoRPB_STRUCT_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 53);
#define FTL_pseudoRPB_ARRAY_SIZE_MISMATCH (FTL_DEBUG_BASE_ERROR_NUMBER + 54);
#define FTL_pseudoRPB_ARRAY_MISALIGNED  (FTL_DEBUG_BASE_ERROR_NUMBER + 55);

FTL_STATUS DEBUG_CompareBuffer(UINT8_PTR source1, UINT8_PTR source2, UINT32 size);
FTL_STATUS DEBUG_FlushDevice(FTL_DEV devID);
FTL_STATUS DEBUG_EraseOp(FTL_DEV devID, UINT16 logicalEBNum);
FTL_STATUS DEBUG_CompareTables(FTL_DEV devID);
FTL_STATUS DEBUG_CompareTablesAll(void);
FTL_STATUS DEBUG_FlushTablesAll(void);

#if (DEBUG_COMPARE_TABLES == FTL_TRUE)
extern UINT8 debugFlushDone;
#endif  // #if (DEBUG_COMPARE_TABLES == FTL_TRUE)
#if (DEBUG_ENABLE_LOGGING == FTL_TRUE)
#define DEBUG_LOG_WRITE       1
#define DEBUG_LOG_READ        2
#define DEBUG_LOG_DELETE      3
#define DEBUG_LOG_INIT        4
#define DEBUG_LOG_FORCED_GC   5
#define DEBUG_LOG_TABLE_FLUSH 6
void DEBUG_ClearLog(void);
FTL_STATUS DEBUG_ReplayLog(UINT32 LBA, UINT32 NB, UINT8 operation);
FTL_STATUS DEBUG_InsertLog(UINT32 LBA, UINT32 NB, UINT8 operation);
FTL_STATUS FTL_DEBUG_Replay(UINT8_PTR FileName);

extern UINT32 APICallLogIndex;
#endif

#endif  // #if (FTL_ENABLE_DEBUG_CODE == FTL_TRUE)


#if (DEBUG_CACHE_RAM_BD_MODULE == FTL_TRUE)

#define DEBUG_DATA_TRANS
#define DEBUG_PROTOTYPE
#define DEBUG_DATA_CLEAR
#define DEBUG_CROSS_BOUNDARY_ROUTE
#define DEBUG_CACHE (FTL_FALSE)

/* To be disabled for release. All associated code shoule be moved to test module, since Test array is independent from cache module core. */
#define DEBUG_TEST_ARRAY 

// for test
// test structure
#define EB_TABLE_SIZE (NUMBER_OF_DEVICES*NUMBER_OF_ERASE_BLOCKS*EBLOCK_MAPPING_ENTRY_SIZE) // for test
#define PPA_TABLE_SIZE (NUMBER_OF_DEVICES*NUMBER_OF_ERASE_BLOCKS*NUMBER_OF_PAGES_PER_EBLOCK*PPA_MAPPING_ENTRY_SIZE) // for test

extern UINT8 EBlockMappingTable[EB_TABLE_SIZE];
extern UINT8 PPAMappingTable[PPA_TABLE_SIZE]; 
#ifdef DEBUG_TEST_ARRAY
extern UINT32 EBlockMappingTableTest[NUMBER_OF_ERASE_BLOCKS][EBLOCK_MAPPING_ENTRY_SIZE/4];
extern UINT32 PPAMappingTableTest[NUMBER_OF_ERASE_BLOCKS][(NUMBER_OF_PAGES_PER_EBLOCK * PPA_MAPPING_ENTRY_SIZE)/4];
#endif
#ifdef DEBUG_PROTOTYPE
extern UINT8 gTestFlag;
extern UINT8 arrayOffsetTemp;
extern UINT16 glogicalEBtemp;
#endif

#ifdef DEBUG_CROSS_BOUNDARY_ROUTE
extern UINT32 gCacheHit;
extern UINT32 gCacheMiss;
extern UINT32 gNoUpAndDownCase;
extern UINT32 gNoDownCase;
extern UINT32 gNoUpCase;
extern UINT32 gDistanceUpAndDownCase;
#endif

#endif // #if (DEBUG_CACHE_RAM_BD_MODULE == FTL_TRUE)



#endif  // #ifndef FTL_DEBUG_H
