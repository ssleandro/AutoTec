/****************************************************************************
 * Title                 :   BOARD CONFIG FILE
 * Filename              :   board.c
 * Author                :   Thiago Palmieri
 * Origin Date           :   10/02/2016
 * Version               :   1.0.1
 * Compiler              :   GCC 5.2 2015q4
 * Target                :   LPC43XX M4
 * Notes                 :   None
 *
 * THIS SOFTWARE IS PROVIDED BY AUTEQ TELEMATICA "AS IS" AND ANY EXPRESSED
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL AUTEQ TELEMATICA OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 *****************************************************************************/
/*************** INTERFACE CHANGE LIST **************************************
 *
 *     Date     Version         Author                Description
 *  10/02/2016   1.0.0      Thiago Palmieri       BOARD CONFIG Created.
 *  25/02/2016   1.0.1      Joao Paulo Martins    SDRAM and LCD feature
 *
 *****************************************************************************/
/** @file board.c
 *  @brief This module provides a Board configuration for the HAL layer
 */

/******************************************************************************
 * Includes
 *******************************************************************************/
#include <board.h>
#include "lpc_types.h"
#include "error.h"

#include "usbd_rom_api.h"
#include "lcd.h"
#include "uart.h"

/******************************************************************************
 * Module Preprocessor Constants
 *******************************************************************************/
#define CAN_MAP_FUNCTION(x) (sCANMap[x ? CAN1b : CAN0b].bModeFunc)
#define CAN_MAP_PORT(x) (sCANMap[x ? CAN1b : CAN0b].bCANPort)
#define CAN_MAP_TD(x) (sCANMap[x ? CAN1b : CAN0b].bCANPinTD)
#define CAN_MAP_RD(x) (sCANMap[x ? CAN1b : CAN0b].bCANPinRD)

#define ADC_MAP_PORT(x) (sADCMap[x ? ADC1b : ADC0b].bADCPort)
#define ADC_MAP_PIN(x) (sADCMap[x ? ADC1b : ADC0b].bADCPin)
#define ADC_MAP_CHANNEL(x) (sADCMap[x ? ADC1b : ADC0b].bADCChannel)
#define ADC_MAP_FUNCTION(x) (sADCMap[x ? ADC1b : ADC0b].bModeFunc)

#define PWM_MAP_PORT(x) (sPWMMap[x == 0 ? PWM0b :(x == 1 ? PWM1b : PWM2b)].bPWMPort)
#define PWM_MAP_PIN(x) (sPWMMap[x == 0 ? PWM0b :(x == 1 ? PWM1b : PWM2b)].bPWMPin)
#define PWM_MAP_FUNCTION(x) (sPWMMap[x == 0 ? PWM0b :(x == 1 ? PWM1b : PWM2b)].bModeFunc)

#define SPIFI_MAP_CLK(x) (sSPIFIMap[x].bSPIFICLK)
#define SPIFI_MAP_PORT(x) (sSPIFIMap[x].bSPIFIPort)
#define SPIFI_MAP_CS(x) (sSPIFIMap[x].bSPIFICS)
#define SPIFI_MAP_D0(x) (sSPIFIMap[x].bSPIFID0)
#define SPIFI_MAP_D1(x) (sSPIFIMap[x].bSPIFID1)
#define SPIFI_MAP_D2(x) (sSPIFIMap[x].bSPIFID2)
#define SPIFI_MAP_D3(x) (sSPIFIMap[x].bSPIFID3)

//#define EMC_LPCOPEN_INIT

/******************************************************************************
 * Module Preprocessor Macros
 *******************************************************************************/

/******************************************************************************
 * Module Typedefs
 *******************************************************************************/

/******************************************************************************
 * Module Variable Definitions
 *******************************************************************************/
//static uint32_t dTimerFreq;
//static uint8_t *pLocalTimerFlag;
//**************************** CAN ****************************
/**
 * X MACRO used to expand to sCANMap the mapping provided by CAN_PIN_MAPPING MACRO
 */
#define X(MO, GO, GP, GR, FU, IR) {.pCAN = MO, .bCANPort = GO, \
        .bCANPinTD = GP, .bCANPinRD = GR, .bModeFunc = FU, .CANIntIRQ = IR},
CANConverter_s sCANMap[] = {
CAN_PIN_MAPPING
	};
#undef X

//**************************** PWM ****************************
/**
 * X MACRO used to expand to sPWMMap the mapping provided by PWM_PIN_MAPPING MACRO
 */
#define X(MO, GO, FU) {.bPWMPort = MO, .bPWMPin = GO, .bModeFunc = FU},
PWMConverter_s sPWMMap[] = {
PWM_PIN_MAPPING
	};
#undef X

//**************************** SPIFI ****************************
/**
 * X MACRO used to expand to sSPIFIMap the mapping provided by SPIFI_PIN_MAPPING MACRO
 */
#define X(PO, CLK, D3, D2, D1, D0, CS, HN) {.bSPIFIPort = PO, .bSPIFICLK = CLK, .bSPIFID3 = D3, .bSPIFID2 = D2, \
        .bSPIFID1 = D1, .bSPIFID0 = D0, .bSPIFICS = CS, .bSPIFIAddress = HN},
SPIFIConverter_s sSPIFIMap[] = {
SPIFI_PIN_MAPPING
	};
#undef X

//**************************** ADC ****************************
/**
 * X MACRO used to expand to sADCMap the mapping provided by ADC_PIN_MAPPING MACRO
 */
#define X(MO, MP, GO, GP, FU, IR, GM) {.pADC = MO, .bADCChannel = MP, .bADCPort = GO, \
        .bADCPin = GP, .bModeFunc = FU, .ADCIntIRQ = IR, .wGPDMA = GM},
ADCConverter_s sADCMap[] = {
ADC_PIN_MAPPING
	};
#undef X

uint32_t bADCMapSize = (uint32_t)(sizeof(sADCMap) / sizeof(sADCMap[0]));
uint8_t bUsedADC[ADC_MAX_CHANNELS] = { 101, 101 };

//**************************** GPIO ****************************
/**
 * X MACRO used to expand to sGPIOMap the mapping provided by GPIO_PIN_MAPPING MACRO
 */
#define X(MO, MP, GO, GP, FU) {.bMainPort = MO, .bMainPin = MP, .bGPIOPort = GO, \
        .bGPIOPin = GP, .bModeFunc = FU},
gpioConverter_s sGPIOMap[] = {
GPIO_PIN_MAPPING
	};
#undef X

uint32_t bGPIOMapSize = (uint32_t)(sizeof(sGPIOMap) / sizeof(sGPIOMap[0]));

//**************************** USB ****************************
/**
 * X MACRO used to expand to sGPIOMap the mapping provided by USB_PIN_MAPPING MACRO
 */
#define X(UB, LUB, IR, FP) {.wLPCUSBBase = UB, .pUSB = LUB, .eLPCUSBIRQ = IR, .USBInitPinClk = FP},
USBConverter_s sUSBMap[] = {
USB_PIN_MAPPING
	};
#undef X

//**************************** UART ***************************
#define X(RG, PT, TX, RX, FU, IR) \
        {.pRegister = RG, .bPort = PT, .bTxPin = TX, .bRxPin = RX, .iModeFunc = FU, .iIRQn = IR},
uartConverter_s sUARTMap[] = {
UART_PIN_MAPPING
	};
#undef X

/* ************************* EMC SDRAM ****************************/
#define X(PO, PI, MO) {.pingrp = PO, .pinnum = PI, .modefunc = MO},
PINMUX_GRP_T sSDRAMMap[] = {
EMC_SDRAM_PIN_MAPPING
	};
#undef X

/* ************************* LCD CONTROLLER ****************************/
#define X(PO, PI, MO) {.pingrp = PO, .pinnum = PI, .modefunc = (MO | SCU_MODE_PULLUP)},
PINMUX_GRP_T sLCDMap[] = {
LCD_PIN_MAPPING
	};
#undef X

/**
 * Structure for initial base clock states
 */
struct CLK_BASE_STATES
{
	CHIP_CGU_BASE_CLK_T clk;  //!< Base clock
	CHIP_CGU_CLKIN_T clkin;   //!< Base clock source, see UM for allowable sources per base clock
	bool autoblock_enab;      //!< Set to true to enable autoblocking on frequency change
	bool powerdn;             //!< Set to true if the base clock is initially powered down
};

/**
 * Initial base clock states are mostly on
 */
STATIC const struct CLK_BASE_STATES InitClkStates[] = {
	{ CLK_BASE_PHY_TX, CLKIN_ENET_TX, true, false },
	#if defined(USE_RMII)
	{	CLK_BASE_PHY_RX, CLKIN_ENET_TX, true, false},
#else
	{ CLK_BASE_PHY_RX, CLKIN_ENET_RX, true, false },
	#endif

	/* Clocks derived from dividers */
	{ CLK_BASE_USB1, CLKIN_IDIVD, true, true },
	{ CLK_BASE_APB1, CLKIN_IDIVE, true, false }
};

/* System configuration variables used by chip driver */
const uint32_t ExtRateIn = 0;         //!< Used by chip driver
const uint32_t OscRateIn = 12000000;  //!< External Oscilator Rate

#ifdef EA_LPC4357
/* SPIFI high speed pin mode setup */
STATIC const PINMUX_GRP_T spifipinmuxing[] =
{
	{	0x3, 3, (SCU_PINIO_FAST | SCU_MODE_FUNC3)}, /* SPIFI CLK */
	{	0x3, 4, (SCU_PINIO_FAST | SCU_MODE_FUNC3)}, /* SPIFI D3 */
	{	0x3, 5, (SCU_PINIO_FAST | SCU_MODE_FUNC3)}, /* SPIFI D2 */
	{	0x3, 6, (SCU_PINIO_FAST | SCU_MODE_FUNC3)}, /* SPIFI D1 */
	{	0x3, 7, (SCU_PINIO_FAST | SCU_MODE_FUNC3)}, /* SPIFI D0 */
	{	0x3, 8, (SCU_PINIO_FAST | SCU_MODE_FUNC3)} /* SPIFI CS/SSEL */
};

STATIC const PINMUX_GRP_T pinmuxing[] =
{
	/* RMII pin group */
	{	0x1, 19, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC0)}, //ENET_REF_CLK
	{	0x0, 1, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC6)}, //ENET_TXEN
	{	0x1, 18, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC3)}, //ENET_TXD0
	{	0x1, 20, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC3)}, //ENET_TXD1
	{	0x1, 17, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC3)}, //ENET_MDIO
	{	0xC, 1, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC3)}, //ENET_MDC
	{	0x1, 16, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC7)}, //ENET_RX_DV
	{	0x1, 15, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC3)}, //ENET_RXD0
	{	0x0, 0, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC2)}, //ENET_RXD1

	/* External data lines D0 .. D31 */
	{	0x1, 7, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0x1, 8, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0x1, 9, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0x1, 10, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0x1, 11, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0x1, 12, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0x1, 13, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0x1, 14, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0x5, 4, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	0x5, 5, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	0x5, 6, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	0x5, 7, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	0x5, 0, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	0x5, 1, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	0x5, 2, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	0x5, 3, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	0xD, 2, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	0xD, 3, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	0xD, 4, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	0xD, 5, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	0xD, 6, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	0xD, 7, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	0xD, 8, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	0xD, 9, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	0xE, 5, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0xE, 6, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0xE, 7, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0xE, 8, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0xE, 9, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0xE, 10, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0xE, 11, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0xE, 12, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},

	/* Address lines A0 .. A23 */
	{	0x2, 9, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0x2, 10, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0x2, 11, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0x2, 12, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0x2, 13, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0x1, 0, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	0x1, 1, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	0x1, 2, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	0x2, 8, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0x2, 7, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0x2, 6, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	0x2, 2, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	0x2, 1, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	0x2, 0, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	0x6, 8, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC1)},
	{	0x6, 7, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC1)},
	{	0xD, 16, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	0xD, 15, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	0xE, 0, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0xE, 1, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0xE, 2, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0xE, 3, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0xE, 4, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	0xA, 4, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},

	/* EMC control signals */
	{	0x1, 4, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)}, //BLS0
	{	0x6, 6, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC1)}, //BLS1
	{	0xD, 13, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)}, //BLS2
	{	0xD, 10, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)}, //BLS3
	{	0x6, 9, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)}, //DYCS0
	{	0x1, 6, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)}, //WE
	{	0x6, 4, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)}, //CAS
	{	0x6, 5, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)}, //RAS
	{	0x6, 11, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)}, //CKEOUT0
	{	0x6, 12, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)}, //DQMOUT0
	{	0x6, 10, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)}, //DQMOUT1
	{	0xD, 0, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)}, //DQMOUT2
	{	0xE, 13, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)}, //DQMOUT3
	{	0x1, 3, (SCU_PINIO_FAST | SCU_MODE_FUNC3)}, //OE
	{	0x1, 5, (SCU_PINIO_FAST | SCU_MODE_FUNC3)}, //CS0
	{	0x6, 3, (SCU_PINIO_FAST | SCU_MODE_FUNC3)}, //CS1
	{	0xD, 12, (SCU_PINIO_FAST | SCU_MODE_FUNC2)}, //CS2
	{	0xD, 11, (SCU_PINIO_FAST | SCU_MODE_FUNC2)}, //CS3
//  {0x6,  1, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC1)}, //DYCS1
//  {0xD, 14, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)}, //DYCS2
//  {0xF, 14, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)}, //DYCS3
//  {0xD, 13, (SCU_PINIO_FAST | SCU_MODE_FUNC3)}, //CS3
//  {0xE, 14, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)}, //DYCS3

	/* SSP0 */
	{	0xF, 0, (SCU_PINIO_FAST | SCU_MODE_FUNC0)}, //SSP0_SCK
	{	0xF, 1, (SCU_PINIO_FAST | SCU_MODE_FUNC2)}, //SSP0_SSEL
	{	0xF, 2, (SCU_PINIO_FAST | SCU_MODE_FUNC2)}, //SSP0_MISO
	{	0xF, 3, (SCU_PINIO_FAST | SCU_MODE_FUNC2)}, //SSP0_MOSI

	/* LCD interface */
	{	0x4, 2, ( SCU_MODE_INACT | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | FUNC2)}, // LCD_VD_3 @ P4.2 - RED0
	{	0x8, 7, ( SCU_MODE_INACT | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | FUNC3)}, // LCD_VD_4 @ P8.7 - RED1
	{	0x8, 6, ( SCU_MODE_INACT | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | FUNC3)}, // LCD_VD_5 @ P8.6 - RED2
	{	0x8, 5, ( SCU_MODE_INACT | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | FUNC3)}, // LCD_VD_6 @ P8.5 - RED3
	{	0x8, 4, ( SCU_MODE_INACT | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | FUNC3)}, // LCD_VD_7 @ P8.4 - RED4
	{	0x4, 10, ( SCU_MODE_INACT | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | FUNC2)}, // LCD_VD_10 @ P4.10 - GREEN0
	{	0x4, 9, ( SCU_MODE_INACT | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | FUNC2)}, // LCD_VD_11 @ P4.9 - GREEN1
	{	0x8, 3, ( SCU_MODE_INACT | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | FUNC3)}, // LCD_VD_12 @ P8.3 - GREEN2
	{	0xB, 6, ( SCU_MODE_INACT | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | FUNC2)}, // LCD_VD_13 @ PB.6 - GREEN3
	{	0xB, 5, ( SCU_MODE_INACT | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | FUNC2)}, // LCD_VD_14 @ PB.5 - GREEN4
	{	0xB, 4, ( SCU_MODE_INACT | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | FUNC2)}, // LCD_VD_15 @ PB.4 - GREEN5
	{	0x7, 1, ( SCU_MODE_INACT | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | FUNC3)}, // LCD_VD_19 @ P7.1 - BLUE0
	{	0xB, 3, ( SCU_MODE_INACT | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | FUNC2)}, // LCD_VD_20 @ PB.3 - BLUE1
	{	0xB, 2, ( SCU_MODE_INACT | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | FUNC2)}, // LCD_VD_21 @ PB.2 - BLUE2
	{	0xB, 1, ( SCU_MODE_INACT | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | FUNC2)}, // LCD_VD_22 @ PB.1 - BLUE3
	{	0xB, 0, ( SCU_MODE_INACT | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | FUNC2)}, // LCD_VD_23 @ PB.0 - BLUE4
	{	0x4, 5, ( SCU_MODE_INACT | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | FUNC2)}, // LCD_FP @ P4.5
	{	0x4, 6, ( SCU_MODE_INACT | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | FUNC2)}, // LCD_ENAB @ P4.6
	{	0x4, 7, ( SCU_MODE_INACT | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | FUNC0)}, // LCD_DCLK @ P4.7
	{	0x7, 0, ( SCU_MODE_INACT | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | FUNC3)}, // LCD_LE @ P7.0
	{	0x7, 6, ( SCU_MODE_INACT | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | FUNC3)}, // LCD_LP @ P7.6
	{	0x7, 7, ( SCU_MODE_INACT | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | FUNC3)}, // LCD_PWR @ P7.7
	{	0xF, 4, ( SCU_MODE_INACT | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | FUNC1)}, // LCD_CLKIN @ PF.4

	/*  I2S  */
	{	0x3, 0, (SCU_PINIO_FAST | SCU_MODE_FUNC2)}, //I2S0_TX_CLK
	{	0xC, 12, (SCU_PINIO_FAST | SCU_MODE_FUNC6)}, //I2S0_TX_SDA
	{	0xC, 13, (SCU_PINIO_FAST | SCU_MODE_FUNC6)}, //I2S0_TX_WS
	{	0x6, 0, (SCU_PINIO_FAST | SCU_MODE_FUNC4)}, //I2S0_RX_SCK
	{	0x6, 1, (SCU_PINIO_FAST | SCU_MODE_FUNC3)}, //I2S0_RX_WS
	{	0x6, 2, (SCU_PINIO_FAST | SCU_MODE_FUNC3)}, //I2S0_RX_SDA

	/*  CCAN  */
	{	0x3, 1, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_FUNC2)}, // P3.1 CAN0 RD
	{	0x3, 2, (SCU_MODE_INACT | SCU_MODE_FUNC2)},                      // P3.2 CAN0 TD */
};
#elif defined (EMC_LPCOPEN_INIT)
STATIC const PINMUX_GRP_T pinmuxingmem[] =
{
	{	1, 0, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	1, 1, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	1, 2, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	1, 7, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	1, 8, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	1, 9, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	1, 10, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	1, 11, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	1, 12, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	1, 13, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	1, 14, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	1, 15, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC6)},
	{	1, 16, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC6)},
	{	1, 18, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC7)},
	{	1, 20, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC7)},
	{	2, 0, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	2, 1, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	2, 2, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	2, 6, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	2, 7, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	2, 8, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	2, 9, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	2, 10, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	2, 11, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	2, 12, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	2, 13, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	5, 0, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	5, 1, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	5, 2, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	{	5, 3, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2)},
	/* EMC control signals */
	{	6, 4, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	6, 5, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	6, 8, (SCU_PINIO_FAST | SCU_MODE_FUNC1)},
	{	6, 9, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	6, 10, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	6, 11, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)},
	{	1, 6, (SCU_PINIO_FAST | SCU_MODE_FUNC3)},
	{	6, 12, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3)}
};
#else
STATIC const PINMUX_GRP_T pinmuxingmem[] = {
	{ 1, 0, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2) },
	{ 1, 1, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2) },
	{ 1, 2, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2) },
	{ 1, 7, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3) },
	{ 1, 8, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3) },
	{ 1, 9, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3) },
	{ 1, 10, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3) },
	{ 1, 11, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3) },
	{ 1, 12, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3) },
	{ 1, 13, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3) },
	{ 1, 14, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3) },
	{ 1, 15, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC6) },
	{ 1, 16, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC6) },
	{ 1, 18, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC7) },
	{ 1, 20, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC7) },
	{ 2, 0, (SCU_MODE_PULLUP | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2) },
	{ 2, 1, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2) },
	{ 2, 2, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2) },
	{ 2, 6, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2) },
	{ 2, 7, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3) },
	{ 2, 8, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3) },
	{ 2, 9, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3) },
	{ 2, 10, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3) },
	{ 2, 11, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3) },
	{ 2, 12, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3) },
	{ 2, 13, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3) },
	{ 5, 0, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2) },
	{ 5, 1, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2) },
	{ 5, 2, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2) },
	{ 5, 3, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC2) },
	/* EMC control signals */
	{ 6, 4, (SCU_MODE_PULLUP | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3) },
	{ 6, 5, (SCU_MODE_PULLUP | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3) },
	{ 6, 8, (SCU_MODE_PULLUP | SCU_MODE_FUNC1) },
	{ 6, 9, (SCU_MODE_PULLUP | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3) },
	{ 6, 10, (SCU_MODE_PULLUP | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3) },
	{ 6, 11, (SCU_MODE_PULLDOWN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3) },
	{ 1, 6, (SCU_MODE_PULLUP | SCU_MODE_FUNC3) },
	{ 6, 12, (SCU_MODE_PULLUP | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC3) }
};
/*
 STATIC const PINMUX_GRP_T pinmuxingmem[] = {
 {1, 0, (SCU_PINIO_FAST | SCU_MODE_FUNC2)},
 {1, 1, (SCU_PINIO_FAST | SCU_MODE_FUNC2)},
 {1, 2, (SCU_PINIO_FAST | SCU_MODE_FUNC2)},
 {1, 6, (SCU_PINIO_FAST | SCU_MODE_FUNC3)},
 {1, 7, (SCU_PINIO_FAST | SCU_MODE_FUNC3)},
 {1, 8, (SCU_PINIO_FAST | SCU_MODE_FUNC3)},
 {1, 9, (SCU_PINIO_FAST | SCU_MODE_FUNC3)},
 {1, 10, (SCU_PINIO_FAST | SCU_MODE_FUNC3)},
 {1, 11, (SCU_PINIO_FAST | SCU_MODE_FUNC3)},
 {1, 12, (SCU_PINIO_FAST | SCU_MODE_FUNC3)},
 {1, 13, (SCU_PINIO_FAST | SCU_MODE_FUNC3)},
 {1, 14, (SCU_PINIO_FAST | SCU_MODE_FUNC3)},
 {1, 15, (SCU_PINIO_FAST | SCU_MODE_FUNC6)},
 {1, 16, (SCU_PINIO_FAST | SCU_MODE_FUNC6)},
 {1, 18, (SCU_PINIO_FAST | SCU_MODE_FUNC7)},
 {1, 20, (SCU_PINIO_FAST | SCU_MODE_FUNC7)},
 {2, 0, (SCU_PINIO_FAST | SCU_MODE_FUNC2)},
 {2, 1, (SCU_PINIO_FAST | SCU_MODE_FUNC2)},
 {2, 2, (SCU_PINIO_FAST | SCU_MODE_FUNC2)},
 {2, 6, (SCU_PINIO_FAST | SCU_MODE_FUNC2)},
 {2, 7, (SCU_PINIO_FAST | SCU_MODE_FUNC3)},
 {2, 8, (SCU_PINIO_FAST | SCU_MODE_FUNC3)},
 {2, 9, (SCU_PINIO_FAST | SCU_MODE_FUNC3)},
 {2, 10, (SCU_PINIO_FAST | SCU_MODE_FUNC3)},
 {2, 11, (SCU_PINIO_FAST | SCU_MODE_FUNC3)},
 {2, 12, (SCU_PINIO_FAST | SCU_MODE_FUNC3)},
 {2, 13, (SCU_PINIO_FAST | SCU_MODE_FUNC3)},
 {5, 0, (SCU_PINIO_FAST | SCU_MODE_FUNC2)},
 {5, 1, (SCU_PINIO_FAST | SCU_MODE_FUNC2)},
 {5, 2, (SCU_PINIO_FAST | SCU_MODE_FUNC2)},
 {5, 3, (SCU_PINIO_FAST | SCU_MODE_FUNC2)},
 {6, 4, (SCU_PINIO_FAST | SCU_MODE_FUNC3)},
 {6, 5, (SCU_PINIO_FAST | SCU_MODE_FUNC3)},
 {6, 8, (SCU_PINIO_FAST | SCU_MODE_FUNC1)},
 {6, 9, (SCU_PINIO_FAST | SCU_MODE_FUNC3)},
 {6, 10, (SCU_PINIO_FAST | SCU_MODE_FUNC3)},
 {6, 11, (SCU_PINIO_FAST | SCU_MODE_FUNC3)},
 {6, 12, (SCU_PINIO_FAST | SCU_MODE_FUNC3)}
 };*/
#endif

/* Pin clock mux values, re-used structure, value in first index is meaningless */
STATIC const PINMUX_GRP_T pinclockmuxing[] = {
	{ 0, 0, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC0) },
	{ 0, 1, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC0) },
	{ 0, 2, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC0) },
	{ 0, 3, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_FUNC0) },
};

#ifdef EA_LPC4357
/* EMC clock delay */
#define CLK0_DELAY 5

/* EA SDRAM timing and chip config */
STATIC const IP_EMC_DYN_CONFIG_T IS42S32800D_config =
{
	EMC_NANOSECOND(64000000 / 4096), /* Row refresh time */
	0x01, /* Command Delayed */
	EMC_NANOSECOND(20),
	EMC_NANOSECOND(45),
	EMC_NANOSECOND(70),
	EMC_CLOCK(0x05),
	EMC_CLOCK(0x05),
	EMC_NANOSECOND(14),
	EMC_NANOSECOND(68),
	EMC_NANOSECOND(68),
	EMC_NANOSECOND(70),
	EMC_NANOSECOND(14),
	EMC_CLOCK(0x02),
	{
		{
			EMC_ADDRESS_DYCS0, /* EA Board uses DYCS0 for SDRAM */
			3, /* RAS */

			EMC_DYN_MODE_WBMODE_PROGRAMMED |
			EMC_DYN_MODE_OPMODE_STANDARD |
			EMC_DYN_MODE_CAS_3 |
			EMC_DYN_MODE_BURST_TYPE_SEQUENTIAL |
			EMC_DYN_MODE_BURST_LEN_4,

			EMC_DYN_CONFIG_DATA_BUS_32 |
			EMC_DYN_CONFIG_8Mx16_4BANKS_12ROWS_9COLS
		},
		{	0, 0, 0, 0},
		{	0, 0, 0, 0},
		{	0, 0, 0, 0}
	}
};

/* NorFlash timing and chip Config */
STATIC const IP_EMC_STATIC_CONFIG_T SST39VF320_config =
{
	0,
	EMC_STATIC_CONFIG_MEM_WIDTH_16 |
	EMC_STATIC_CONFIG_CS_POL_ACTIVE_LOW |
	EMC_STATIC_CONFIG_BLS_HIGH,

	EMC_NANOSECOND(0),
	EMC_NANOSECOND(35),
	EMC_NANOSECOND(70),
	EMC_NANOSECOND(70),
	EMC_NANOSECOND(40),
	EMC_CLOCK(4)
};

/* NandFlash timing and chip Config */
STATIC const IP_EMC_STATIC_CONFIG_T K9F1G_config =
{
	1,
	EMC_STATIC_CONFIG_MEM_WIDTH_8 |
	EMC_STATIC_CONFIG_CS_POL_ACTIVE_LOW |
	EMC_STATIC_CONFIG_BLS_HIGH,

	EMC_NANOSECOND(0),
	EMC_NANOSECOND(35),
	EMC_NANOSECOND(70),
	EMC_NANOSECOND(70),
	EMC_NANOSECOND(40),
	EMC_CLOCK(4)
};

/*
 * Configuration for the memory mapped LEDs on the OEM Base Board
 */
STATIC const IP_EMC_STATIC_CONFIG_T memreg_config =
{
	2,
	EMC_STATIC_CONFIG_MEM_WIDTH_16,

	EMC_NANOSECOND(0),
	EMC_NANOSECOND(0),
	EMC_NANOSECOND(0),
	EMC_NANOSECOND(0),
	EMC_NANOSECOND(0),
	EMC_CLOCK(4)
};
#endif

/******************************************************************************
 * Function Prototypes
 *******************************************************************************/

/******************************************************************************
 * Function Definitions
 *******************************************************************************/
/******************************************************************************
 * Function : pvt_BRD_dNano2Clock(uint32_t freq, uint32_t time)
 *//**
 * \b Description:
 *
 * This function calculates the number of clock cycles of an amout of time.
 * It takes the frequency of an peripheral (in Hz) and the time required (in nanoseconds)
 * as arguments and returns an integer that is the number of clock cycles.
 *
 * PRE-CONDITION: The correct number of the peripheral or system frequency.
 *
 * POST-CONDITION: none
 *
 * @return uint32_t with the number of cycles of the required time.
 *
 * \b Example
 ~~~~~~~~~~~~~~~{.c}
 *   uint32_t clk_hz = Chip_Clock_GetBaseClocktHz(CLK_BASE_MX);
 *	uint32_t ncycles;
 *
 *   ncycles = pvt_BRD_dNano2Clock(clk_hz, 100);
 ~~~~~~~~~~~~~~~
 *
 * @see
 *
 * <br><b> - HISTORY OF CHANGES - </b>
 *
 * <table align="left" style="width:800px">
 * <tr><td> Date       </td><td> Software Version </td><td> Initials </td><td> Description </td></tr>
 * <tr><td> 03/02/2016 </td><td> 1.0.0            </td><td> TP       </td><td> Interface Created </td></tr>
 * </table><br><br>
 * <hr>
 *
 *******************************************************************************/
void BRD_vWait_ms (uint32_t ms)
{
#ifdef CORE_M4
	volatile static int initialized = 0;
	if (!initialized)
	{
		initialized = 1;
		StopWatch_Init();
	}
	StopWatch_DelayMs(ms);
#else
	uint32_t i;
	while(ms >= 70000)
	{
		Board_DelayMs(10000);
		ms -= 10000;
	}
	i = 30000*ms;
	while (i--);
#endif
}

void BRD_vWait_us (uint32_t us)
{
#ifdef CORE_M4
	volatile static int initialized = 0;
	if (!initialized)
	{
		initialized = 1;
		StopWatch_Init();
	}
	StopWatch_DelayUs(us);
#else
	uint32_t i = 41*us;
	while (i--);
#endif
}

void SystemInit (void)
{
#if defined(CORE_M3) || defined(CORE_M4)
	unsigned int *pSCB_VTOR = (unsigned int *)0xE000ED08;

#if defined(__IAR_SYSTEMS_ICC__)
	extern void *__vector_table;

	*pSCB_VTOR = (unsigned int) &__vector_table;
#elif defined(__GNUC__)
	extern void *g_pfnVectors;

	*pSCB_VTOR = (unsigned int)&g_pfnVectors;
#elif defined(__ARMCC_VERSION)
	extern void *__Vectors;

	*pSCB_VTOR = (unsigned int) &__Vectors;
#endif

#if defined(__FPU_PRESENT) && __FPU_PRESENT == 1
	fpuInit();
#endif

#if defined(NO_BOARD_LIB)
	/* Chip specific SystemInit */
	Chip_SystemInit();
#else
	/* Board specific SystemInit */
	BRD_SystemInit();
#endif

#endif /* defined(CORE_M3) || defined(CORE_M4) */
}

void BRD_vSystemCoreClockUpdate (void)
{
	SystemCoreClock = Chip_Clock_GetRate(CLK_MX_MXCORE);
}

void BRD_UARTConfig (uint8_t UART_Index)
{

	/* Config the PINMUX for the TX Pin */
	Chip_SCU_PinMuxSet(sUARTMap[UART_Index].bPort, sUARTMap[UART_Index].bTxPin,
		(sUARTMap[UART_Index].iModeFunc | SCU_MODE_INACT));

	/* Config the PINMUX for the RX Pin */
	Chip_SCU_PinMuxSet(sUARTMap[UART_Index].bPort, sUARTMap[UART_Index].bRxPin,
		(sUARTMap[UART_Index].iModeFunc | SCU_MODE_INACT |
		SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS));

	/* Init microcontroller selected UART */
	Chip_UART_Init(sUARTMap[UART_Index].pRegister);
}

uint32_t BRD_PWMConfig (uint8_t PWMChannel)
{
	Chip_SCU_PinMuxSet(PWM_MAP_PORT(PWMChannel), PWM_MAP_PIN(PWMChannel),
		(MD_PLN_FAST | SCU_MODE_PULLDOWN | PWM_MAP_FUNCTION(PWMChannel)));
	Chip_Clock_Enable(CLK_APB1_MOTOCON);
	return Chip_Clock_GetRate(CLK_APB1_MOTOCON);
}

void BRD_SPIFIConfig (void)
{
	Chip_SCU_PinMuxSet(SPIFI_MAP_PORT(SPIFI0b), SPIFI_MAP_CLK(SPIFI0b), (SCU_PINIO_FAST | SCU_MODE_FUNC3));
	Chip_SCU_PinMuxSet(SPIFI_MAP_PORT(SPIFI0b), SPIFI_MAP_D3(SPIFI0b), (SCU_PINIO_FAST | SCU_MODE_FUNC3));
	Chip_SCU_PinMuxSet(SPIFI_MAP_PORT(SPIFI0b), SPIFI_MAP_D2(SPIFI0b), (SCU_PINIO_FAST | SCU_MODE_FUNC3));
	Chip_SCU_PinMuxSet(SPIFI_MAP_PORT(SPIFI0b), SPIFI_MAP_D1(SPIFI0b), (SCU_PINIO_FAST | SCU_MODE_FUNC3));
	Chip_SCU_PinMuxSet(SPIFI_MAP_PORT(SPIFI0b), SPIFI_MAP_D0(SPIFI0b), (SCU_PINIO_FAST | SCU_MODE_FUNC3));
	Chip_SCU_PinMuxSet(SPIFI_MAP_PORT(SPIFI0b), SPIFI_MAP_CS(SPIFI0b), (SCU_PINIO_FAST | SCU_MODE_FUNC3));
}

uint32_t BRD_CANConfig (uint8_t CANChannel)
{
	uint32_t rate;

	//Pinmux
	Chip_SCU_PinMuxSet(CAN_MAP_PORT(CANChannel), CAN_MAP_RD(CANChannel),
		(SCU_MODE_INACT | SCU_MODE_INBUFF_EN | CAN_MAP_FUNCTION(CANChannel))); //RD
	Chip_SCU_PinMuxSet(CAN_MAP_PORT(CANChannel), CAN_MAP_TD(CANChannel),
		(SCU_MODE_INACT | CAN_MAP_FUNCTION(CANChannel))); //TD

	if (CANChannel)
	{
		//Clock enable
		Chip_Clock_SetBaseClock(CLK_BASE_APB1, CLKIN_IDIVC, true, false);
		//    uint32_t rate = Chip_Clock_GetRate(CLK_APB3_CAN0);
		rate = Chip_Clock_GetRate(CLK_APB1_CAN1);
	}
	else
	{
		//Clock enable
		Chip_Clock_SetBaseClock(CLK_BASE_APB3, CLKIN_IDIVC, true, false);
		//    uint32_t rate = Chip_Clock_GetRate(CLK_APB3_CAN0);
		rate = Chip_Clock_GetRate(CLK_APB3_CAN0);
	}
	return rate;
}

void BRD_ADCConfig (uint8_t ADCChannel)
{
	if (bUsedADC[ADCChannel] <= bADCMapSize) // Check if Pin Mux is required
	{
		Chip_SCU_PinMuxSet(ADC_MAP_PORT(ADCChannel), ADC_MAP_PIN(ADCChannel), ADC_MAP_FUNCTION(ADCChannel));
	}
	Chip_SCU_ADC_Channel_Config(ADCChannel, ADC_MAP_CHANNEL(ADCChannel));
}

void BRD_GPIOConfig (uint8_t GPIOChannel, uint8_t bPull)
{
	//PinMux
	Chip_SCU_PinMuxSet(
		sGPIOMap[GPIOChannel].bMainPort,
		sGPIOMap[GPIOChannel].bMainPin,
		(bPull | SCU_PINIO_FAST | sGPIOMap[GPIOChannel].bModeFunc));

}

STATIC const IP_EMC_DYN_CONFIG_T AS4C16M16SA_config = {
	EMC_NANOSECOND(64000000 / 8192), /* Row refresh time */
	0x01, /* Command Delayed */
	EMC_CLOCK(2), /*! tRP */
	EMC_CLOCK(3), /*! tRAS */
	EMC_CLOCK(4), /*! tSREX */
	EMC_CLOCK(5), /*! tAPR */
	EMC_CLOCK(5), /*! tDAL */
	EMC_CLOCK(3), /*! tWR */
	EMC_CLOCK(5), /*! tRC */
	EMC_CLOCK(5), /*! tRFC */
	EMC_CLOCK(5), /*! tXSR */
	EMC_CLOCK(1), /*! tRRD */
	EMC_CLOCK(3), /*! tMRD */
	{
		{
		EMC_ADDRESS_DYCS0, /* PROTOB uses DYCS0 for SDRAM */
		3, /* RAS */

		EMC_DYN_MODE_WBMODE_PROGRAMMED |
		EMC_DYN_MODE_OPMODE_STANDARD |
		EMC_DYN_MODE_CAS_3 |
		EMC_DYN_MODE_BURST_TYPE_SEQUENTIAL |
		EMC_DYN_MODE_BURST_LEN_8,

		EMC_DYN_CONFIG_DATA_BUS_16 |
		EMC_DYN_CONFIG_16Mx16_4BANKS_13ROWS_9COLS |
		EMC_DYN_CONFIG_MD_SDRAM
		},
		{ 0, 0, 0, 0 },
		{ 0, 0, 0, 0 },
		{ 0, 0, 0, 0 }
	}
};

#define CLOCK_FREQ_204MHz 204000000
#define CLOCK_FREQ_144MHz 144000000
#define CLOCK_FREQ_120MHz 120000000

#define CLOCK_FREQUENCY CLOCK_FREQ_204MHz

/* Set up and initialize clocking prior to call to main */
void BRD_vSetupClocking (void)
{
	int i;

	/* Setup FLASH acceleration to target clock rate prior to clock switch */
	Chip_CREG_SetFlashAcceleration(MAX_CLOCK_FREQ);

	Chip_SetupCoreClock(CLKIN_CRYSTAL, MAX_CLOCK_FREQ, true);

	/* Setup system base clocks and initial states. This won't enable and
	 disable individual clocks, but sets up the base clock sources for
	 each individual peripheral clock. */
	for (i = 0; i < (sizeof(InitClkStates) / sizeof(InitClkStates[0])); i++)
	{
		Chip_Clock_SetBaseClock(InitClkStates[i].clk, InitClkStates[i].clkin,
			InitClkStates[i].autoblock_enab, InitClkStates[i].powerdn);
	}

	/* Reset and enable 32Khz oscillator */
	LPC_CREG->CREG0 &= ~((1 << 3) | (1 << 2));
	LPC_CREG->CREG0 |= (1 << 1) | (1 << 0);

	/* Setup a divider E for main PLL clock switch SPIFI clock to that divider.
	 Divide rate is based on CPU speed and speed of SPI FLASH part. */
#if (MAX_CLOCK_FREQ > 180000000)
	Chip_Clock_SetDivider(CLK_IDIV_E, CLKIN_MAINPLL, 5);
#else
	Chip_Clock_SetDivider(CLK_IDIV_E, CLKIN_MAINPLL, 4);
#endif
	Chip_Clock_SetBaseClock(CLK_BASE_SPIFI, CLKIN_IDIVE, true, false);
}

/******************************************************************************
 * Function : pvt_BRD_SDRAMConfig(void)
 *//**
 * \b Description:
 *
 * This function initializes the pins connected to an external SDRAM memory and
 * enables the device for operation.
 *
 * PRE-CONDITION: An array of PINMUX_GRP_T elements, one for each of SDRAM controller pins.
 *
 * POST-CONDITION: An external SDRAM device enabled and operational, acessible by the system
 * with base address 0x2800000.
 *
 * @return     void
 *
 * \b Example
 ~~~~~~~~~~~~~~~{.c}
 * PINMUX_GRP_T sSDRAMMap[] = {.pingrp = 1, .pinnum = 0, .modefunc = (SCU_PINIO_FAST | SCU_MODE_FUNC2 | SCU_MODE_PULLUP)}, \
  {.pingrp = 1, .pinnum = 1, .modefunc = (SCU_PINIO_FAST | SCU_MODE_FUNC2 | SCU_MODE_PULLUP)}, \
  {.pingrp = 1, .pinnum = 2, .modefunc = (SCU_PINIO_FAST | SCU_MODE_FUNC2 | SCU_MODE_PULLUP)}, \
  {.pingrp = 1, .pinnum = 3, .modefunc = (SCU_PINIO_FAST | SCU_MODE_FUNC2 | SCU_MODE_PULLUP)}, \
  {.pingrp = 1, .pinnum = 4, .modefunc = (SCU_PINIO_FAST | SCU_MODE_FUNC2 | SCU_MODE_PULLUP)}, \
  {.pingrp = 1, .pinnum = 5, .modefunc = (SCU_PINIO_FAST | SCU_MODE_FUNC2 | SCU_MODE_PULLUP)};
 */

void BRD_ExtMemoryConfig (void)
{
#ifdef EA_LPC4357
	/* Setup EMC Delays */
	/* Move all clock delays together */
	LPC_SCU->EMCDELAYCLK = ((CLK0_DELAY) | (CLK0_DELAY << 4) | (CLK0_DELAY << 8) | (CLK0_DELAY << 12));

	if (MAX_CLOCK_FREQ >= 120000000)
	{
		/* Setup EMC Clock Divider for divide by 2 - this is done in both the CCU (clocking)
		 and CREG. For frequencies over 120MHz, a divider of 2 must be used. For frequencies
		 less than 120MHz, a divider of 1 or 2 is ok. */
		Chip_Clock_EnableOpts(CLK_MX_EMC_DIV, true, true, 2);
		LPC_CREG->CREG6 |= (1 << 16);
	}
	else
	{
		/* Setup EMC Clock Divider for divide by 1 (i.e. same as core) */
		Chip_Clock_EnableOpts(CLK_MX_EMC_DIV, true, true, 1);
		LPC_CREG->CREG6 &= ~(1 << 16);
	}

	/* Enable EMC clock */
	Chip_Clock_Enable(CLK_MX_EMC);

	/* Init EMC Controller -Enable-LE mode- clock ratio 1:1 */
	Chip_EMC_Init(1, 0, 0);
	/* Init EMC Dynamic Controller */
	Chip_EMC_Dynamic_Init((IP_EMC_DYN_CONFIG_T *) &IS42S32800D_config);

	/* Init EMC Static Controller CS0 */
	Chip_EMC_Static_Init((IP_EMC_STATIC_CONFIG_T *) &SST39VF320_config);

	/* Init EMC Static Controller CS1 */
	Chip_EMC_Static_Init((IP_EMC_STATIC_CONFIG_T *) &K9F1G_config);

	/* Init Memory Controlled LEDs CS2 */
	Chip_EMC_Static_Init((IP_EMC_STATIC_CONFIG_T *) &memreg_config);

	/* Enable Buffer for External NOR Flash */
	LPC_EMC->STATICCONFIG0 |= 1 << 19;
#else
#define CLK0_DELAY 2

	/* Setup EMC Delays */
	/* Move all clock delays together */
	LPC_SCU->EMCDELAYCLK = ((CLK0_DELAY) | (CLK0_DELAY << 4) | (CLK0_DELAY << 8) | (CLK0_DELAY << 12));

	if (MAX_CLOCK_FREQ >= 120000000)
	{
		/* Setup EMC Clock Divider for divide by 2 - this is done in both the CCU (clocking)
		 and CREG. For frequencies over 120MHz, a divider of 2 must be used. For frequencies
		 less than 120MHz, a divider of 1 or 2 is ok. */
		Chip_Clock_EnableOpts(CLK_MX_EMC_DIV, true, true, 2);
		LPC_CREG->CREG6 |= (1 << 16);
	}
	else
	{
		/* Setup EMC Clock Divider for divide by 1 (i.e. same as core) */
		Chip_Clock_EnableOpts(CLK_MX_EMC_DIV, true, true, 1);
		LPC_CREG->CREG6 &= ~(1 << 16);
	}

	/* Enable EMC clock */
	Chip_Clock_Enable(CLK_MX_EMC);

	/* Init EMC Controller -Enable-LE mode- clock ratio 1:1 */
	Chip_EMC_Init(1, 0, 0);
	/* Init EMC Dynamic Controller */
	Chip_EMC_Dynamic_Init((IP_EMC_DYN_CONFIG_T *)&AS4C16M16SA_config);

	/* Enable Buffer for External NOR Flash */
	LPC_EMC->STATICCONFIG0 |= 1 << 19;
#endif
}

void BRD_LCDConfig (void)
{
	/* Set the on-board SDRAM to use as framebuffer */
	//pvt_BRD_SDRAMConfig();
	/* Setup LCD pin muxing */
	Chip_SCU_SetPinMuxing(sLCDMap, sizeof(sLCDMap) / sizeof(PINMUX_GRP_T));

	/* Enable clock */
	Chip_Clock_EnableOpts(CLK_MX_LCD, true, true, 1);
}

void BRD_SetupMuxing (void)
{
	int i;
// TODO: Define an MACRO to setup all system level pin muxing as in EA_LPC4357 embedded kit
#ifdef EA_LPC4357
	/* Setup system level pin muxing */
	Chip_SCU_SetPinMuxing(pinmuxing, sizeof(pinmuxing) / sizeof(PINMUX_GRP_T));
#else
	/* Setup SDRAM pin muxing */
	Chip_SCU_SetPinMuxing(pinmuxingmem, sizeof(pinmuxingmem) / sizeof(PINMUX_GRP_T));
#endif

	/* Clock pins only, group field not used */
	for (i = 0; i < (sizeof(pinclockmuxing) / sizeof(pinclockmuxing[0])); i++)
	{
		Chip_SCU_ClockPinMuxSet(pinclockmuxing[i].pinnum, pinclockmuxing[i].modefunc);
	}

#ifdef EA_LPC4357
	/* SPIFI pin setup is done prior to setting up system clocking */
	Chip_SCU_SetPinMuxing(spifipinmuxing, sizeof(spifipinmuxing) / sizeof(PINMUX_GRP_T));
	{
		int j;
		int num = sizeof(pinmuxing) / sizeof(PINMUX_GRP_T);
		// verify that no pins are defined twice
		for (i = 0; i < num; i++)
		{
			for (j = i+1; j < num; j++)
			{
				if ((pinmuxing[i].pingrp == pinmuxing[j].pingrp) &&
						(pinmuxing[i].pinnum == pinmuxing[j].pinnum))
				{
					// Found conflicting setup
					while(1)
					{
						num = num + 0; /* Should handle this better, but at least it is a breakpoint */
					}
				}
			}
		}
	}
#endif
}

void BRD_SystemInit (void)
{
	// Set up pinmux and verify
	BRD_SetupMuxing();
	// Set up clocking
	BRD_vSetupClocking();
	// Set up external memories
	BRD_ExtMemoryConfig();
	/* Clears the UART devices list */
	UART_vInitPeripheralList();
}
